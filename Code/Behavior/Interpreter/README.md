## 解释器模式

解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它主要用于描述如何使用面向对象语言构成一个简单的语言解释器。

解释器（Interpreter）模式：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种行为型模式。

<img src="https://images2017.cnblogs.com/blog/381412/201709/381412-20170912225232094-718404042.png"/>

解释器模式主要包含以下4个角色：

- AbstractExpression（抽象表达式）：声明了抽象的解释操作；

- TerminalExpression（终结符表达式）：抽象表达式的子类，实现了与文法中的终结符相关联的解释操作，在句中的每一个终结符都是该类的一个实例；

- NonterminalExpression（非终结符表达式）：抽象表达式的子类，实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归完成。

- Context（环境类）：又称为上下文类，用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。

### 设计架构

<img src="https://images2017.cnblogs.com/blog/381412/201709/381412-20170912225348516-1542482561.png" />

其中，Context充当环境类角色，Node充当抽象表达式角色，ExpressionNode、CommandNode和LoopCommandNode充当非终结符表达式角色，PrimitiveCommandNode充当终结符表达式角色。

### 主要优点
- 易于改变和扩展文法 => 通过继承来改变或扩展
- 增加新的解释表达式较为方便 => 只需对应新增一个新的终结符或非终结符表达式，原有代码无须修改，符合开闭原则！

### 主要缺点
- 对于复杂文法难以维护 => 一条规则一个类，如果太多文法规则，类的个数会剧增！
- 执行效率较低 => 使用了大量循环和递归，在解释复杂句子时速度很慢！

### 应用场景 
- 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
- 一些重复出现的问题可以用一种简单的语言来进行表达
- 一个语言的文法较为简单
- 执行效率不是关键问题 => 高效的解释器通常不是通过直接解释抽象语法树来实现的