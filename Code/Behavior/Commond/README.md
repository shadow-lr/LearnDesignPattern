## 命令模式

**将一个请求封装为一个对象**，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。在OOP中，一切都是对象，将请求封装成对象，符合OOP的设计思想，当将客户的单个请求封装成对象以后，我们就可以对这个请求存储更多的信息，使请求拥有更多的能力；命令模式同样能够把请求发送者和接收者解耦，使得命令发送者不用去关心请求将以何种方式被处理
<img src="https://images0.cnblogs.com/blog2015/631817/201504/171633521206876.png"/>

Command：声明执行操作的接口；

ConcreteCommand：将一个接收者对象绑定于一个动作，之后，调用接收者相应的操作，以实现Execute来完成相应的命令；

Client：创建一个具体命令对象，但是并没有设定它的接收者；

Invoker：要求该命令执行这个请求；

Receiver：知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者。

以上这些对象是按照下面的方式进行协作的：

1.Client创建一个ConcreteCommand命令对象，并指定它的Receiver对象；
2.Invoker对象存储该ConcreteCommand对象；
3.该Invoker通过调用Command对象的Execute操作来提交一个请求。如果这个命令请求是可以撤销的，ConcreteCommand就执行Execute操作之前存储当前状态以用于取消该命令请求；
4.ConcreteCommand对象调用Receiver的一些操作以执行该请求。

### 具体事例：

我们去餐厅吃饭，我们是通过服务员来点菜，具体是谁来做这些菜和他们什么时候完成的这些菜，其实我们都不知道。抽象之，我们是“菜单请求者”，厨师是“菜单实现者”，2者之间是松耦合的，我们对这些菜的其他一些请求比如“撤销，重做”等，我们也不知道是谁在做。其实这就是本文要说的Command模式。将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作